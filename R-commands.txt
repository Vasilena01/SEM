Initializing vectors:
- logs <- vector("logical", length=5) - taka konstruirame vector, (<the data type>, <length>), default value is: 0
- v <- c(5, 7, -5, 4, 3, D) - indexing starts from 1!
- v[3] = -5
- v[c(4, 1, 2)] - shte ni izvede, stojnostta na 4-to, 1-vo i 2-ro mqsto
- v[-2] - prints all elements except from the second one; 5, -5, 4, 3, D
- v[-c(4, 1, 2)] - prints: -5, 3, 0
- len <- length(v) - =6
- c(1:len) = 1, 2, 3, ... len
- v[-c(1:len)] - prints nothing

Sort:
- w <- sort(v)
- v[order(v)] - returns v as sorted
- v[v %% 2 == 0] - returns just the even nums from v
- v[v > 4] - returns just the nums from v, which are > then 4

If\Else:
n <- o
m <- ifelse(<condition>, <value if true>, <value if false>) // something like the ternary operator

Functions:
bools <- c(T, T, F, F, T)
- any(bools) - returns true if just one is true
- all(bools) - returns true if all are true
- duplicated(bools) - returns true if min 2 elements are equal to each other
- anyDuplicated(<array of nums>) - returns true if two or more nums are the same
- unique(any) - returns a vector from all unique elements from the given vector in the brackets (any) - in our case
- !sample(<vector of values>, <count of elements to pick>, <with replace?>):
    sample(c(1, 100), 10, true) - iskam ot tozi vector da mi izberesh 10 elementa s vrushtane, zashtoto replace=true
    sample(c(1, 100), 10, false) - shte izteglq razlichni chisla
    sample(c(0,1), 143, true, prob=c(0.08, 0.92)) - teglq iz mejdu dve stojnosti, vsqka ot koito moje da se padne s prob(0.08, 0.92), t.e prioritiziraj da teglish edinici otkolkoto 0
- replicate(<num of times to call the function/second arg>, <function/other>)
- rbinom(1, size = 10, prob = 0.25) - vrushta masiv s "vernite otgovori" samo, kato veroqtnostta da gi izeberesh e 0.25
- which(<array> == 1) - if we have an array, it returns an array with the indicies of every num equals to 1, from the given array
- which.max(<array>) - returns the index of the largest element in the array
 
Agregating functions:
- diff(c(1,2,3,7,-5)) - gledame gi po dvoiki i novoobrazuwaniq vector e = c(2-1, 3-2, 7-3, -5-7) = (1, 1, 4, -12)
- cumsum(c(1,2,3,7,-5)) - purviq si ostava sushtiq, vtoriq e sum na purvite dva, tretiq na purvite tri i tn
- rep(<element>, <times>, <each=>) - kato repeat,
- primerno: rep(1, 3) = (1, 1, 1)
- rep(c(1,2), <times=>3) = (1, 2, 1, 2, 1, 2) - da se povtori po 3 puti vectora - (1,2)
- rep(c(1, 2), <each=>3) = (1, 1, 1, 2, 2, 2) - vseki element da e povtoren po 3 puti
- seq(<from - start=>, <to - stop=>, <by - step=>):
- seq(1, 10, 2) = (1, 3, 5, 7, 9)
- seq(10, 1, -2) = (10, 8, 6, 4, 2)
- seq(1, n, 1) equal to seq(1:n) - pod default stupkata e 1

Matrix:
- ako iskame tazi matrica -> ((1, 2, 4);(7, 8, 9)):
- M <- rbind(c(1,2,4),c(7,8,9)) - obrazuva matricata 2x3, slaga gi edno pod drugo - po redove
- M <- cbind(c(1,2,4),c(7,8,9)) - obrazuva matricata 3x2, slaga gi edno do drugo - po koloni - 1,2,4 i drugata kolona: 7,8,9
- matrix(<vector with the values>, <nrow=>, <ncd=>, <byrow=>)
matrix(c(1:16), 4, 4) - matricata se podrejda po koloni 1,2,3,4 - purvata kolona i tn...
matrix(c(1:16), 4, 4, TRUE) - matricata se podrejda po redove 1,2,3,4 - purviq red ...
- M[3] - returns 9 - po default slaga edinica otpred = M[1,3]
- M[3,] - returns the whole third line
- M[,3] - returns the whole third column
- M[c(1,2), c(3,4)] - vrushta kato matrica purviq?
- M[1,4] - returns 13
- v <- c(5,6,7); v^2 = (25, 36, 49)
- rowSums(<matrix>) - returns a vector with the sums of each row of the given matrix

Bernulievo/Binomno razpredelenie functions - вероятността при n "хвърляния" например, да имаме k успеха, с вероятност за всеки успех p
d - = (точно)
p - <= (не повече)
r - random

dbinom(k,n,p) = P(X=k) - hvurlqme, ver da se sluchi edno el subitie (f), returns nums (tochno sled n)
pbinom(k,n,p) = P(X <= k) - veroqtnostta da se sluchat vsichki el subitiq (F), returns nums (sled ne po-malko/po-golqmo ot n)
rbinom(N,n,p) = c(...); N - broq puti da izvikame eksperimenta sus stojnosti n, p (neshto kato prob funkciqta, koqto izpolzvahme v zadachite ot prakt1 i prakt2)

Геометрично разпределение - вероятността да изтеглим 1 "успех" при точно или <= n "хвърляния"
dgeom(k,p) = P(X=k) - izpulnqvame k puti dadeno subitie i kakva e ver. v k ot tezi hvurlqniq da imame pone edin uspeh, kato ver da se sluchat subitiqta e p, (tochno sled n)
pgeom(k,p) = P(X <= k) - suma na dgeom(i, p), i = 1..k, (sled ne po-malko/po-golqmo ot n)
rgeom(N, k, p) = c(...) - na purviq izhod imam uspeh, na N-tiq neuspeh i tn

NBinom - вероятността да имаме k - неуспеха, между n - успеха, с вер. на хвърлянето p 
dnbinom(k,n,p) = P(X=k) - 
pnbinom(k,n,p) = P(X <= k) - 
rnbinom(N,n,p)

Hyper - описва вероятността при избор без връщане от м-во с два вида елементи, да бъдат изтеглени определен брой от единия тип елементи
dhyper(x,m,n,k) - точно x - count of the els from the searched type, m - total count of els from searched type, n - total count of other type els, k - total picks count
phyper - <= x
rhyper - random

Pois - вероятността даден брой събития да се случат във фиксиран интервал от време, като знаем тяхната средна честота
 dpois(x, lambda) - точно x - броя събития да настъпят, като знаем, че в този интервал ппц настъпват -> lambda на брой събития, lambda - среден брой събития, които настъпват в даден интервал
 ppois (x, l) - <= X
 rpois(x, l) - random n стойности от разпределението
